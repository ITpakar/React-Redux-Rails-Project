exit
self.commentable.traverse_up_to klass
c
self.commentable
self.class
self.association_map.keys.include? klass.to_s
klass
self
c
self.status
self.status_was
self.status_was != self.status and self.status == "Closed"
c
reload!
self.status
self.status_was
c
exit
Event.create(deal_id: self.deal_id, type: "TASK_COMPLETED", subject_type: "Task", subject_id: self.id)
exit
self.deal_size
self.deal_sie
c
redux_store('doxlyStore', props: @redux_store_data)
c
@redux_store_data
c
@redux_store_data
c
starred_deals
c
@redux_store_data
c
@redux_store_data
c
cc
c
exit
resource_name
current_user
resource = warden.user(resource_name)
warden.authenticated?(resource_name)
current_user
warden.authenticated?(resource_name)
    no_input = devise_mapping.no_input_strategies
is_navigational_format?
assert_is_devise_resource!
c
current_user
c
after_resetting_password_path_for(resource)
sign_in(resource_name, resource)
resource
resource_name
Devise.sign_in_after_reset_password
exit
params
c
params
exit
params
original_token       = attributes[:reset_password_token]
attributes
exit
resource_params
c
params
resource_params
resource_class
self.resource = resource_class.reset_password_by_token(resource_params)
c
args
c
args
c
resource_params
resource_class.send_reset_password_instructions(resource_params)
resource_class.send_reset_password_instructions
resource_class
c
exit
Deal.last.friendly_date
Deal.last
Date.new(string)
Date.methods
DateTime.parse(string)
DateTime.parse
Date.parse(string)
string = "11/15/2016"
Deal.first
Deal.first.update_attributes(projected_close_date: Date.today)
Deal.first
Deal.first.update_attributes(projected_close_date: '11/15/2016')
Deal.first
deal_params[:projected_close_date]
Date.parse(deal_params[:projected_close_date])
Date.parse(deal_params[:projected_close_date]
@deal
@deal.projected_close_date = deal_params[:projected_close_date]
deal.projected_close_date = deal_params[:projected_close_date]
deal_params
@deal
c
p deal_params
deal_params
c
api_deals_path
path
exit
c
file
file.title
file.name
file.try(:name) || file.try(:title)
exit
Document.first
id
self.deal_id
deal_id
exit
save
deal_id = parent.deal_id
Document.find(id)
Deal.find(1).deal_id
Deal.find(1)
id
deal_id
exit
c
"/#{domain}/".to_regex
"/#{domain}/".to_regexp
"/#{domain}/"
/domain/
domain = /@(.+)$/.match(email).captures.first
/@(.+)$/.match(email).captures.first
email = User.first.email
User.first.email
team_members = deal_for_stats.map(&:users).flatten.uniq.count
team_members = deal_for_stats.map(&:users).flatten.uniq
team_members = deals_for_stats.map(&:users).flatten.uniq
deal_for_stats.where(status: ACTIVE_STATUSES)
deals_for_stats.where(status: ACTIVE_STATUSES)
deals_for_stats.where(status: ACTIVE_STATUSES]
deals_for_stats.active_statuses
deals.where(status: ACTIVE_STATUSES).count
deals.count
deals.where(status: ACTIVE_STATUSES)
deals
c
grouped = deals.group_by {|deal| DateTime.parse(deal["projected_close_date"].to_s).strftime("%B %Y")}
exit
deals[0]["projected_close_date"]
deals["projected_close_date"]
deals.attributes
deals.first
grouped = deals.group_by {|deal| DateTime.parse(deal[:projected_close_date].to_s).strftime("%B %Y")}
c
exit
deal = Deal.create( organization_id: 1, title: 'Project Panda', client_name: 'Panda Express', projected_close_date: '2016-07-24', transaction_type: 'Merger', deal_size: '$1,500,000,000', completion_percent: 9, admin_user_id: 1, activated: true, projected_close_date: 1.year.from_now)
Deal.create(id: 1, organization_id: 1, title: 'Project Panda', client_name: 'Panda Express', projected_close_date: '2016-07-24', transaction_type: 'Merger', deal_size: '$1,500,000,000', completion_percent: 9, admin_user_id: 1, activated: true, projected_close_date: 1.year.from_now)
Deal.create( #id: 1, organization_id: 1, title: 'Project Panda', client_name: 'Panda Express', projected_close_date: '2016-07-24', transaction_type: 'Merger', deal_size: '$1,500,000,000', completion_percent: 9, admin_user_id: 1, activated: true, projected_close_date: 1.year.from_now)
1.year.from_now
deals.first[:projected_close_date]
deals.first[:[:projected_close_date]
deals.first.attributes
deals.first
deals
deals.first.attributes[:projected_close_date]
c
deal
c
User.all.map(&:avatar_name)
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first[:collaborators].first.avatar_name
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first[:collaborators].first.avatar
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first[:collaborators].first
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first[:collaborators]
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first.collaborators
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first.keys
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first.collaborators
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first.collaborators.first
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first.users.first
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}.first
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})}
current_user.deals.includes(:users).map{|deal| deal.attributes.merge({collaborators: deal.users})
current_user.deals.includes(:users).first.attributes.merge({})
current_user.deals.includes(:users).first.attributes
current_user.deals.includes(:users).first.users.count
current_user.deals.includes(:users).first.users
current_user.deals.includes(:users).first
current_user.deals.includes(:users)
current_user.deals.includes(:user)
current_user.deals.includes(:user).first
current_user.deals.includes(:user)
deals.merge
deals = deals.map{|deal| deal.collaborators = deal.users}
deals = deals.map{|deal| deal.collaborators = deal.users; deal}
deals = current_user.deals.includes(:deal_collaborators)
current_user.deals.includes(:deal_collaborators).first.class
current_user.deals.includes(:deal_collaborators).first
current_user.deals.includes(:deal_collaborators)
current_user.deals.includes(:deal_collaborator).first
current_user.deals.includes(:deal_collaborators).first
Deal.all.includes(:deal_collaborators)
Deal.includes(:deal_collaborators).all
Deal.includes(:deal_collaborators)
current_user.deals.includes(:deal_collaborators).first.deal_collaborators
current_user.deals.includes(:deal_collaborators).first
current_user.deals.includes(:deal_collaborators)
current_user.deals.includes
current_user.deals.joins(:deal_collaborators).first
current_user.deals.joins(:deal_collaborators)
current_user.deals.joins
current_user.deals
grouped.keys
grouped
grouped[1]
grouped[0]
grouped.count
grouped = @deals.group_by {|deal| DateTime.parse(deal.projected_close_date.to_s).strftime("%B %Y")}
@deals.group_by {|deal| DateTime.parse(deal.projected_close_date.to_s).strftime("%B %Y")}
@deals.group_by {|deal| DateTime.parse(deal.projected_close_date).strftime("%B %Y")}
DateTime.parse(string).strftime("%B %Y")
DateTime.parse(string).strftime("%B")
DateTime.parse(string).strftime("%B)
DateTime.parse(string).strftime
DateTime.parse(string)
string = "2015-12-01"
@deals.group_by {|deal| deal.projected_close_date}
@deals.group_by(:projected_close_date)
@deals
@deals.group_by@deals
@deals.group_by
@deals.group_b
@deals
@deals.to_h
@deals.to_hash
@deals
c
current_user
exit
deals.map(&:completion_percent)
deals.map(&:completion_percentage)
deals.map(&:competion_percentage)
deal.map(&:competion_percentage)
deals.map(&:activated)
deals.map(&:status)
deals
c
params
