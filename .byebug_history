c
mail(to: @email, subject: "You've been invited to join #{organization.name.capitalize} on Doxly")
organization
email
name
@name
c
params
c
deal.status
deal
exit
User.last.destroy
app_user_confirmation_url(@resource)
app_user_confirmation_url
api_user_url(@resource)
api_user_url
app_user_confirmation_url(@resource)
app_user_confirmation_path(@resource)
new_app_user_confirmation_url(@resource)
app_user_confirmation_url(@resource)
@resource
app_user_confirmation_url(@resource, confirmation_token: @token)
c
current_user.context.deals.count
c
reload!
OrganizationUser.first.deals
Deal.where(organization_user_id: 1).count
Deal.where(organization_user_id: 1)
current_user.organization_user.id
current_user.organization_user.deals
current_user.context.class
current_user.context
current_user.organization.deals.count
current_user.organization.deals
current_user.organization
current_user.context.deals.uniq.count
current_user.context.deals.uniq
current_user.context.deals.count
c
user.errors
User.last
user = User.create(user_params)
user.save
user = User.new(user_params)
user_params
User.where(email: 'chintan@seedfeed.com')
user.save
user.activated = true
user.email_domain
user = User.new(user_params)
exit
c
Comment.find(2)
Comment.last
self
c
self
c
Comment.first
self
klass
c
assoc_value = self.send(mapped) if mapped.present?
mapped = self.association_map[klass.to_s]
self
klass
c
self
klass
klas
exit
self.try(:send, self.association_map.try(:[], klass.to_s))
self.association_map.try(:[], klass.to_s)
 assoc_value = self.try(:send, self.association_map.try(:[], klass.to_s))
 assoc_value = self.try(:send, self.association_map.try(:[], klass.to_s)
exit
self.association_map
self.association_map[klass.to_s]
klass
self.class
c
klass
c
deal
c
send("_#{kind}")
"_#{kind}"
options = args.last
c
manager._run_callbacks
manager.config
manager.callbacks
manager.methods
manager
c
manager._run_callbacks(:after_set_user, user, self, opts) if run_callbacks
run_callbacks = opts.fetch(:run_callbacks, true)
session_serializer.store(user, scope)
options[:renew] = true if options
options = env[ENV_SESSION_OPTIONS]
opts[:store] != false && opts[:event] != :fetch
@users[scope] = user
opts[:event] ||= :set_user
opts = (@config[:scope_defaults][scope] || {}).merge(opts)
scope = (opts[:scope] ||= @config.default_scope)
opts
user
c
cc
c
warden.session_serializer.store(resource, options)
warden.session_serializer(resource, options)
options = options.merge!(scope: scope)
options
warden.session_serializer
session_serializer
warden.user
warden
c
warden.set_user(resource)
options.merge!(scope: scope)
c
warden.set_user(resource, options.merge!(scope: scope))
warden.user(scope) == resource
options[:bypass]
expire_data_after_sign_in!
 resource = args.last || resource_or_scope
scope    = Devise::Mapping.find_scope!(resource_or_scope)
args
options  = args.extract_options!
c
sign_in("user", resource)
resource and resource.valid_password?(params[:user][:password])
resource = User.find_for_database_authentication(email: params[:user][:email])
c
warden
warden.authenticate(auth_options)
self.resource = warden.authenticate!(auth_options)
c
